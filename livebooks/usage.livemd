# Control Gemini CLI from Livebook

```elixir
Mix.install([
  {:acpex, path: "/code/edgar/acpex"},
  {:jason, "~> 1.4"},
  {:kino, "~> 0.14"}
])
```

## üöÄ Introduction

Welcome to an **interactive demonstration** of ACPex controlling Google's Gemini CLI agent!

In this livebook, you'll build a complete AI coding assistant interface that:

* ü§ñ Connects to **Gemini CLI** via the Agent Client Protocol (ACP)
* üí¨ Sends prompts and receives intelligent responses
* üìÅ Allows the agent to **read and write files** on your system
* üñ•Ô∏è Enables the agent to **execute terminal commands**
* üé® Provides a beautiful **interactive UI** powered by Kino

This is a **real, working implementation** - not a simulation! You'll be controlling an actual AI agent that can help you write code, analyze projects, and perform complex tasks.

## üìã Prerequisites

Before running this livebook, ensure you have:

### 1. Gemini CLI Installed

Choose one of these methods:

**Option A: NPM (Node.js 20+)**

```bash
npm install -g @google/gemini-cli
```

**Option B: Homebrew (macOS/Linux)**

```bash
brew install gemini-cli
```

**Option C: One-time run with npx**

```bash
npx @google/gemini-cli
```

### 2. Authentication

Gemini CLI requires authentication. The easiest way is:

```bash
gemini auth login
```

Alternatively, set the `GEMINI_API_KEY` environment variable:

```bash
export GEMINI_API_KEY="your-api-key-here"
```

Get your API key from: https://aistudio.google.com/apikey

### 3. Verify Installation

Check that Gemini CLI is available:

```elixir
gemini_path = System.find_executable("/Users/edgar/.npm-global/bin/gemini")

if gemini_path do
  Kino.Markdown.new("""
  ‚úÖ **Gemini CLI found!**

  Path: `#{gemini_path}`
  """)
else
  Kino.Markdown.new("""
  ‚ùå **Gemini CLI not found!**

  Please install it using one of the methods above, then restart the runtime.
  """)
end
```

## üé® Building the Interactive UI

Let's create a beautiful dashboard for controlling the agent!

````elixir
# Create UI components
defmodule UI do
  def create_dashboard do
    %{
      # Status indicator
      status_frame: Kino.Frame.new(),

      # Agent output area
      output_frame: Kino.Frame.new(),

      # File operations log
      file_log_frame: Kino.Frame.new(),

      # Terminal output
      terminal_frame: Kino.Frame.new(),

      # Input controls
      prompt_input:
        Kino.Input.textarea("üí≠ Your Prompt",
          default: "Analyze the structure of this ACPex library and suggest improvements."
        ),
      model_selector:
        Kino.Input.select(
          "Model",
          [
            {"gemini-2.5-pro", "Gemini 2.5 Pro (Most Capable)"},
            {"gemini-2.5-flash", "Gemini 2.5 Flash (Faster)"}
          ],
          default: "gemini-2.5-flash"
        ),

      # Action buttons
      start_button: Kino.Control.button("üöÄ Start Agent"),
      stop_button: Kino.Control.button("üõë Stop Agent"),
      send_button: Kino.Control.button("üì§ Send Prompt")
    }
  end

  def render_dashboard(ui) do
    Kino.Layout.grid(
      [
        # Header
        Kino.Markdown.new("## ü§ñ Gemini CLI Agent Controller"),

        # Status Section
        Kino.Layout.grid([
          Kino.Markdown.new("### Status"),
          ui.status_frame
        ]),

        # Control Section
        Kino.Layout.grid([
          Kino.Markdown.new("### Controls"),
          Kino.Layout.grid([ui.start_button, ui.stop_button], columns: 2),
          ui.model_selector
        ]),

        # Prompt Section
        Kino.Layout.grid([
          Kino.Markdown.new("### Prompt"),
          ui.prompt_input,
          ui.send_button
        ]),

        # Output Section
        Kino.Layout.grid([
          Kino.Markdown.new("### üí¨ Agent Response"),
          ui.output_frame
        ]),

        # File Operations
        Kino.Layout.grid([
          Kino.Markdown.new("### üìÅ File Operations"),
          ui.file_log_frame
        ]),

        # Terminal Output
        Kino.Layout.grid([
          Kino.Markdown.new("### üñ•Ô∏è Terminal Output"),
          ui.terminal_frame
        ])
      ],
      columns: 1
    )
  end

  def update_status(frame, status, color \\ :blue) do
    icon =
      case status do
        :disconnected -> "‚≠ï"
        :connecting -> "üîÑ"
        :connected -> "‚úÖ"
        :error -> "‚ùå"
        _ -> "‚ÑπÔ∏è"
      end

    color_code =
      case color do
        :green -> "#22c55e"
        :red -> "#ef4444"
        :blue -> "#3b82f6"
        :yellow -> "#eab308"
        _ -> "#6b7280"
      end

    Kino.Frame.render(
      frame,
      Kino.Markdown.new("""
      <div style="padding: 12px; background: #{color_code}22; border-left: 4px solid #{color_code}; border-radius: 4px;">
        <strong>#{icon} #{status |> to_string() |> String.upcase()}</strong>
      </div>
      """)
    )
  end

  def log_file_operation(frame, operation, path, success \\ true) do
    icon = if success, do: "‚úÖ", else: "‚ùå"

    emoji =
      case operation do
        :read -> "üìñ"
        :write -> "‚úçÔ∏è"
        _ -> "üìÑ"
      end

    timestamp = DateTime.utc_now() |> DateTime.to_string()

    Kino.Frame.append(
      frame,
      Kino.Markdown.new("""
      `#{timestamp}` #{icon} #{emoji} **#{operation}** `#{path}`
      """)
    )
  end

  def log_terminal(frame, command, output \\ nil) do
    content =
      if output do
        """
        ```bash
        $ #{command}
        #{output}
        ```
        """
      else
        """
        ```bash
        $ #{command}
        ```
        """
      end

    Kino.Frame.append(frame, Kino.Markdown.new(content))
  end

  def render_agent_update(frame, update) do
    content =
      case update do
        %{"kind" => "thought", "content" => text} ->
          "üí≠ **Thinking:** #{text}"

        %{"kind" => "message", "content" => text} ->
          "üí¨ **Response:**\n\n#{text}"

        %{"kind" => "tool_call", "tool" => tool, "args" => args} ->
          "üîß **Tool Call:** `#{tool}`\n```json\n#{Jason.encode!(args, pretty: true)}\n```"

        %{"kind" => "plan", "steps" => steps} ->
          steps_text =
            steps
            |> Enum.with_index(1)
            |> Enum.map(fn {step, i} -> "#{i}. #{step}" end)
            |> Enum.join("\n")

          "üìã **Plan:**\n\n#{steps_text}"

        _ ->
          "‚ÑπÔ∏è **Update:** #{inspect(update)}"
      end

    Kino.Frame.append(frame, Kino.Markdown.new(content <> "\n\n---\n"))
  end
end

# Create and render the dashboard
ui = UI.create_dashboard()
dashboard = UI.render_dashboard(ui)

# Initialize status
UI.update_status(ui.status_frame, :disconnected, :red)

dashboard
````

### üîå Implementing the ACPex Client

Now let's create a full-featured client that implements all ACP callbacks:

```elixir
defmodule GeminiClient do
  @moduledoc """
  A complete ACPex client implementation for controlling Gemini CLI.

  This client handles:
  - Session updates and streams them to the UI
  - File system operations (read/write)
  - Terminal operations (create, execute, monitor)
  """

  @behaviour ACPex.Client

  def init(args) do
    ui = Keyword.fetch!(args, :ui)

    state = %{
      ui: ui,
      sessions: %{},
      terminals: %{},
      files_accessed: []
    }

    {:ok, state}
  end

  @doc """
  Handle streaming updates from the agent.

  These come in as the agent thinks, plans, and generates responses.
  """
  def handle_session_update(params, state) do
    update = params["update"]

    # Render to the output frame
    UI.render_agent_update(state.ui.output_frame, update)

    {:noreply, state}
  end

  @doc """
  Handle agent requests to read files.

  The agent might need to read source code, config files, etc.
  """
  def handle_fs_read_text_file(%{"path" => path}, state) do
    UI.log_file_operation(state.ui.file_log_frame, :read, path)

    # Resolve relative paths from the current directory
    full_path = Path.expand(path)

    case File.read(full_path) do
      {:ok, content} ->
        UI.log_file_operation(state.ui.file_log_frame, :read, path, true)
        new_state = %{state | files_accessed: [path | state.files_accessed]}
        {:ok, %{"content" => content}, new_state}

      {:error, reason} ->
        UI.log_file_operation(state.ui.file_log_frame, :read, path, false)

        error = %{
          "code" => -32001,
          "message" => "Failed to read file: #{reason}"
        }

        {:error, error, state}
    end
  end

  @doc """
  Handle agent requests to write files.

  The agent can create new files or modify existing ones.
  """
  def handle_fs_write_text_file(%{"path" => path, "content" => content}, state) do
    UI.log_file_operation(state.ui.file_log_frame, :write, path)

    full_path = Path.expand(path)

    # Create parent directory if it doesn't exist
    full_path |> Path.dirname() |> File.mkdir_p()

    case File.write(full_path, content) do
      :ok ->
        UI.log_file_operation(state.ui.file_log_frame, :write, path, true)
        new_state = %{state | files_accessed: [path | state.files_accessed]}
        {:ok, %{"bytes_written" => byte_size(content)}, new_state}

      {:error, reason} ->
        UI.log_file_operation(state.ui.file_log_frame, :write, path, false)

        error = %{
          "code" => -32002,
          "message" => "Failed to write file: #{reason}"
        }

        {:error, error, state}
    end
  end

  @doc """
  Create a new terminal for the agent to use.
  """
  def handle_terminal_create(%{"command" => command} = params, state) do
    terminal_id = "term-" <> Base.encode16(:crypto.strong_rand_bytes(8), case: :lower)

    UI.log_terminal(state.ui.terminal_frame, command)

    # In a real implementation, you might use Port or System.cmd
    # For this demo, we'll simulate it
    terminal_info = %{
      id: terminal_id,
      command: command,
      cwd: params["cwd"] || File.cwd!(),
      output: ""
    }

    new_terminals = Map.put(state.terminals, terminal_id, terminal_info)

    {:ok, %{"terminal_id" => terminal_id}, %{state | terminals: new_terminals}}
  end

  @doc """
  Get output from a terminal.
  """
  def handle_terminal_output(%{"terminal_id" => terminal_id}, state) do
    case Map.get(state.terminals, terminal_id) do
      nil ->
        error = %{"code" => -32003, "message" => "Terminal not found"}
        {:error, error, state}

      terminal ->
        # Simulate running the command
        {output, exit_code} =
          try do
            System.cmd("sh", ["-c", terminal.command],
              cd: terminal.cwd,
              stderr_to_stdout: true
            )
          rescue
            _ -> {"Error executing command", 1}
          end

        # Update terminal with output
        updated_terminal = %{terminal | output: output}
        new_terminals = Map.put(state.terminals, terminal_id, updated_terminal)

        UI.log_terminal(state.ui.terminal_frame, terminal.command, output)

        {:ok, %{"output" => output, "exit_code" => exit_code},
         %{state | terminals: new_terminals}}
    end
  end

  @doc """
  Wait for a terminal command to finish.
  """
  def handle_terminal_wait_for_exit(%{"terminal_id" => terminal_id}, state) do
    case Map.get(state.terminals, terminal_id) do
      nil ->
        error = %{"code" => -32003, "message" => "Terminal not found"}
        {:error, error, state}

      _terminal ->
        # In our simulation, commands finish immediately
        {:ok, %{"exit_code" => 0}, state}
    end
  end

  @doc """
  Kill a running terminal command.
  """
  def handle_terminal_kill(%{"terminal_id" => terminal_id}, state) do
    case Map.get(state.terminals, terminal_id) do
      nil ->
        error = %{"code" => -32003, "message" => "Terminal not found"}
        {:error, error, state}

      _terminal ->
        new_terminals = Map.delete(state.terminals, terminal_id)
        {:ok, %{}, %{state | terminals: new_terminals}}
    end
  end

  @doc """
  Release a terminal (cleanup).
  """
  def handle_terminal_release(%{"terminal_id" => terminal_id}, state) do
    new_terminals = Map.delete(state.terminals, terminal_id)
    {:ok, %{}, %{state | terminals: new_terminals}}
  end
end

:ok
```

### üöÄ Starting the Agent Connection

Now let's connect to Gemini CLI! This cell will:

1. Find the Gemini CLI executable
2. Start the ACPex client connection
3. Spawn Gemini CLI as a subprocess with `--experimental-acp` flag

<!-- livebook:{"break_markdown":true} -->

‚ö†Ô∏è **Note:** Make sure you've authenticated with Gemini CLI first (`gemini auth login`)

```elixir
# Store the connection in the process dictionary so we can access it later
agent_connection = Process.get(:agent_connection)

if agent_connection && Process.alive?(agent_connection) do
  Kino.Markdown.new("""
  ‚ö†Ô∏è **Agent already running!**

  Click the üõë Stop Agent button below to stop it first.
  """)
else
  # Find Gemini CLI
  gemini_path = System.find_executable("/Users/edgar/.npm-global/bin/gemini")

  if gemini_path do
    # Start the agent with --experimental-acp flag for Gemini CLI
    result =
      ACPex.start_client(
        GeminiClient,
        [ui: ui],
        agent_path: gemini_path,
        agent_args: ["--experimental-acp"]
      )

    case result do
      {:ok, conn_pid} ->
        # Store connection for later use
        Process.put(:agent_connection, conn_pid)
        Process.put(:current_session_id, nil)

        UI.update_status(ui.status_frame, :connected, :green)

        Kino.Markdown.new("""
        ‚úÖ **Agent Connected!**

        Gemini CLI is now running and ready to receive prompts.

        The agent is running with `--experimental-acp` flag at:
        `#{gemini_path}`
        """)

      {:error, reason} ->
        UI.update_status(ui.status_frame, :error, :red)

        Kino.Markdown.new("""
        ‚ùå **Connection Failed!**

        Error: #{inspect(reason)}

        Make sure Gemini CLI is properly installed and you're authenticated.
        """)
    end
  else
    UI.update_status(ui.status_frame, :error, :red)

    Kino.Markdown.new("""
    ‚ùå **Gemini CLI not found!**

    Please install it and restart the runtime.
    """)
  end
end
```

### üîÑ Initialize the Agent

Before we can send prompts, we need to initialize the connection:

````elixir
agent_connection = Process.get(:agent_connection)

if agent_connection && Process.alive?(agent_connection) do
  # Send initialize request
  init_response =
    ACPex.Protocol.Connection.send_request(
      agent_connection,
      "initialize",
      %{
        "protocol_version" => "1.0",
        "capabilities" => %{
          "filesystem" => true,
          "terminal" => true
        },
        "client_info" => %{
          "name" => "Livebook",
          "version" => "0.1.0"
        }
      },
      # 30 second timeout
      30_000
    )

  case init_response do
    %{"result" => result} ->
      Kino.Markdown.new("""
      ‚úÖ **Agent Initialized!**

      **Protocol Version:** #{result["protocol_version"]}

      **Agent Info:**
      ```json
      #{Jason.encode!(result["agent_info"] || %{}, pretty: true)}
      ```

      **Capabilities:**
      ```json
      #{Jason.encode!(result["capabilities"] || %{}, pretty: true)}
      ```
      """)

    %{"error" => error} ->
      Kino.Markdown.new("""
      ‚ùå **Initialization Failed!**

      Error: #{error["message"]}
      """)

    _ ->
      Kino.Markdown.new("""
      ‚ö†Ô∏è **Unexpected Response**

      #{inspect(init_response)}
      """)
  end
else
  Kino.Markdown.new("""
  ‚ö†Ô∏è **Agent not connected!**

  Please run the "Starting the Agent Connection" cell above first.
  """)
end
````

### üí¨ Create a Session

Let's create a conversation session:

```elixir
agent_connection = Process.get(:agent_connection)

if agent_connection && Process.alive?(agent_connection) do
  # Create a new session
  session_response =
    ACPex.Protocol.Connection.send_request(
      agent_connection,
      "session/new",
      %{},
      10_000
    )

  case session_response do
    %{"result" => %{"session_id" => session_id}} ->
      # Store session ID for later
      Process.put(:current_session_id, session_id)

      Kino.Markdown.new("""
      ‚úÖ **Session Created!**

      Session ID: `#{session_id}`

      You're now ready to send prompts to the agent!
      """)

    %{"error" => error} ->
      Kino.Markdown.new("""
      ‚ùå **Session Creation Failed!**

      Error: #{error["message"]}
      """)

    _ ->
      Kino.Markdown.new("""
      ‚ö†Ô∏è **Unexpected Response**

      #{inspect(session_response)}
      """)
  end
else
  Kino.Markdown.new("""
  ‚ö†Ô∏è **Agent not connected!**

  Please run the "Starting the Agent Connection" cell above first.
  """)
end
```

### üéØ Send Prompts to the Agent

Now for the fun part! Use the interactive form to send prompts:

```elixir
# Get connection and session
agent_connection = Process.get(:agent_connection)
session_id = Process.get(:current_session_id)

# Listen to the send button
send_stream = Kino.Control.stream(ui.send_button)

Kino.listen(send_stream, fn _event ->
  if agent_connection && Process.alive?(agent_connection) && session_id do
    # Clear the output frame
    Kino.Frame.clear(ui.output_frame)

    # Get the prompt from the input
    prompt_text = Kino.Input.read(ui.prompt_input)

    if prompt_text && String.trim(prompt_text) != "" do
      # Show that we're sending
      UI.render_agent_update(ui.output_frame, %{
        "kind" => "message",
        "content" => "**You:** #{prompt_text}"
      })

      # Send the prompt
      Task.async(fn ->
        response =
          ACPex.Protocol.Connection.send_request(
            agent_connection,
            "session/prompt",
            %{
              "session_id" => session_id,
              "content" => prompt_text,
              "context" => %{
                "cwd" => File.cwd!()
              }
            },
            # 2 minute timeout
            120_000
          )

        case response do
          %{"result" => result} ->
            UI.render_agent_update(ui.output_frame, %{
              "kind" => "message",
              "content" => "‚úÖ **Complete!**\n\nStop Reason: #{result["stop_reason"]}"
            })

          %{"error" => error} ->
            UI.render_agent_update(ui.output_frame, %{
              "kind" => "message",
              "content" => "‚ùå **Error:** #{error["message"]}"
            })

          _ ->
            UI.render_agent_update(ui.output_frame, %{
              "kind" => "message",
              "content" => "‚ö†Ô∏è Unexpected response: #{inspect(response)}"
            })
        end
      end)
    end
  else
    Kino.Frame.render(
      ui.output_frame,
      Kino.Markdown.new("‚ö†Ô∏è **Not connected!** Please connect and initialize first.")
    )
  end
end)

Kino.Markdown.new("""
‚ú® **Ready to chat!**

Type your prompt in the textarea above and click "üì§ Send Prompt".

The agent will:
- Stream its thinking process in real-time
- Read files if needed (you'll see them in the File Operations log)
- Execute commands if needed (you'll see them in Terminal Output)
- Generate intelligent responses

Try asking:
- "Analyze the architecture of this ACPex library"
- "What are the main modules and what do they do?"
- "Find all public functions and generate documentation stubs"
- "Add a test for the ACPex.Json.decode function"
""")
```

### üõë Stop the Agent

When you're done, stop the agent:

```elixir
# Listen to stop button
stop_stream = Kino.Control.stream(ui.stop_button)

Kino.listen(stop_stream, fn _event ->
  agent_connection = Process.get(:agent_connection)

  if agent_connection && Process.alive?(agent_connection) do
    # Stop the connection
    Process.exit(agent_connection, :normal)
    Process.put(:agent_connection, nil)
    Process.put(:current_session_id, nil)

    UI.update_status(ui.status_frame, :disconnected, :red)

    Kino.Frame.render(
      ui.output_frame,
      Kino.Markdown.new("üëã **Agent stopped!**")
    )
  end
end)

Kino.Markdown.new("‚úÖ Stop button listener active")
```

### üìö Example Prompts to Try

Here are some interesting prompts to explore ACPex's capabilities:

#### 1. Code Analysis

```
Analyze the ACPex.Protocol.Connection module. Explain its role in the architecture
and how it manages sessions.
```

#### 2. Generate Tests

```
Look at lib/acpex/json.ex and generate comprehensive unit tests for the decode
functions. Place them in test/acpex/json_test.exs.
```

#### 3. Documentation

```
Review all public functions in lib/acpex.ex and ensure they have proper @doc
and @spec annotations. Add any that are missing.
```

#### 4. Refactoring

```
Examine the session routing logic in lib/acpex/protocol/session.ex and suggest
any improvements for clarity or performance.
```

#### 5. Create New Feature

```
Add a new function to ACPex that lists all active connections and their session
counts. Include tests.
```

### üéâ Summary

Congratulations! You've built a complete, working integration between:

* **Livebook** - Your interactive notebook environment
* **Kino** - Beautiful, reactive UI components
* **ACPex** - Your Elixir ACP protocol implementation
* **Gemini CLI** - Google's powerful AI coding assistant

<!-- livebook:{"break_markdown":true} -->

#### What You Learned

1. **Protocol Implementation**: How to implement a full ACPex client with all callbacks
2. **File System Integration**: How agents can read and write files through your client
3. **Terminal Integration**: How agents can execute commands safely
4. **Real-time UI**: How to build reactive interfaces with Kino
5. **Agent Communication**: How the Agent Client Protocol enables tool interoperability

<!-- livebook:{"break_markdown":true} -->

#### Next Steps

* Experiment with different prompts and see what Gemini can do
* Try implementing additional ACP features (like session persistence)
* Build your own custom agent using ACPex
* Create a web interface using Phoenix LiveView
* Integrate with other MCP-compatible tools

<!-- livebook:{"break_markdown":true} -->

#### Resources

* **ACPex Documentation**: Check out the HexDocs for ACPex
* **ACP Specification**: https://agentclientprotocol.com
* **Gemini CLI**: https://github.com/google-gemini/gemini-cli
* **Kino Documentation**: https://hexdocs.pm/kino

---

**Happy Coding!** üöÄ
